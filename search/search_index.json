{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"flask-cors","text":"<p>A Flask extension for handling Cross Origin Resource Sharing (CORS), making cross-origin AJAX possible.</p> <p>This package has a simple philosophy: when you want to enable CORS, you wish to enable it for all use cases on a domain. This means no mucking around with different allowed headers, methods, etc.</p> <p>By default, submission of cookies across domains is disabled due to the security implications. Please see the documentation for how to enable credential\\'ed requests, and please make sure you add some sort of CSRF protection before doing so!</p>"},{"location":"#installation","title":"Installation","text":"<p>Install the extension with using pip, uv, or your favorite package manager</p> <pre><code>pip install -U flask-cors\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>This package exposes a Flask extension which by default enables CORS support on all routes, for all origins and methods. It allows parameterization of all CORS headers on a per-resource level. The package also contains a decorator, for those who prefer this approach.</p> <p>In the simplest case, initialize the Flask-Cors extension with default arguments in order to allow CORS for all domains on all routes. See the full list of options in the documentation.</p> <pre><code>from flask import Flask\nfrom flask_cors import CORS\n\napp = Flask(__name__)\nCORS(app)\n\n@app.route(\"/\")\ndef helloWorld():\n  return \"Hello, cross-origin-world!\"\n</code></pre>"},{"location":"#using-cors-with-cookies","title":"Using CORS with Cookies","text":"<p>By default, Flask-CORS does not allow cookies to be submitted across sites, since it has potential security implications. If you wish to enable cross-site cookies, you may wish to add some sort of CSRF protection to keep you and your users safe.</p> <p>To allow cookies or authenticated requests to be made cross origins, simply set the <code>supports_credentials</code> option to <code>True</code>. E.g.</p> <pre><code>    from flask import Flask, session\n    from flask_cors import CORS\n\n    app = Flask(__name__)\n    CORS(app, supports_credentials=True)\n\n    @app.route(\"/\")\n    def helloWorld():\n      return \"Hello, %s\" % session['username']\n</code></pre>"},{"location":"decorator/","title":"Decorator","text":"<p>This function is the decorator which is used to wrap a Flask route with. In the simplest case, simply use the default parameters to allow all origins in what is the most permissive configuration. If this method modifies state or performs authentication which may be brute-forced, you should add some degree of protection, such as Cross Site Request Forgery protection.</p> <p>Parameters:</p> Name Type Description Default <code>origins</code> <code>list, string | regex</code> <p>The origin, or list of origins to allow requests from. The origin(s) may be regular expressions, case-sensitive strings, or else an asterisk  Default : '*'</p> required <code>methods</code> <code>list | string</code> <p>The method or list of methods which the allowed origins are allowed to access for non-simple requests.  Default : [GET, HEAD, POST, OPTIONS, PUT, PATCH, DELETE]</p> required <code>expose_headers</code> <code>list | string</code> <p>The header or list which are safe to expose to the API of a CORS API specification.  Default : None</p> required <code>allow_headers</code> <code>list, string | regex</code> <p>The header or list of header field names which can be used when this resource is accessed by allowed origins. The header(s) may be regular expressions, case-sensitive strings, or else an asterisk.  Default : '*', allow all headers</p> required <code>supports_credentials</code> <code>bool</code> <p>Allows users to make authenticated requests. If true, injects the <code>Access-Control-Allow-Credentials</code> header in responses. This allows cookies and credentials to be submitted across domains.  :note: This option cannot be used in conjunction with a '*' origin  Default : False</p> required <code>max_age</code> <code>timedelta, integer, string | None</code> <p>The maximum time for which this CORS request maybe cached. This value is set as the <code>Access-Control-Max-Age</code> header.  Default : None</p> required <code>send_wildcard</code> <code>bool</code> <p>If True, and the origins parameter is <code>*</code>, a wildcard <code>Access-Control-Allow-Origin</code> header is sent, rather than the request's <code>Origin</code> header.  Default : False</p> required <code>vary_header</code> <code>bool</code> <p>If True, the header Vary: Origin will be returned as per the W3 implementation guidelines.  Setting this header when the <code>Access-Control-Allow-Origin</code> is dynamically generated (e.g. when there is more than one allowed origin, and an Origin than '*' is returned) informs CDNs and other caches that the CORS headers are dynamic, and cannot be cached.  If False, the Vary header will never be injected or altered.  Default : True</p> required <code>automatic_options</code> <code>bool</code> <p>Only applies to the <code>cross_origin</code> decorator. If True, Flask-CORS will override Flask's default OPTIONS handling to return CORS headers for OPTIONS requests.  Default : True</p> required Source code in <code>flask_cors/decorator.py</code> <pre><code>def cross_origin(*args, **kwargs):\n    \"\"\"\n    This function is the decorator which is used to wrap a Flask route with.\n    In the simplest case, simply use the default parameters to allow all\n    origins in what is the most permissive configuration. If this method\n    modifies state or performs authentication which may be brute-forced, you\n    should add some degree of protection, such as Cross Site Request Forgery\n    protection.\n\n    :param origins:\n        The origin, or list of origins to allow requests from.\n        The origin(s) may be regular expressions, case-sensitive strings,\n        or else an asterisk\n\n        Default : '*'\n    :type origins: list, string or regex\n\n    :param methods:\n        The method or list of methods which the allowed origins are allowed to\n        access for non-simple requests.\n\n        Default : [GET, HEAD, POST, OPTIONS, PUT, PATCH, DELETE]\n    :type methods: list or string\n\n    :param expose_headers:\n        The header or list which are safe to expose to the API of a CORS API\n        specification.\n\n        Default : None\n    :type expose_headers: list or string\n\n    :param allow_headers:\n        The header or list of header field names which can be used when this\n        resource is accessed by allowed origins. The header(s) may be regular\n        expressions, case-sensitive strings, or else an asterisk.\n\n        Default : '*', allow all headers\n    :type allow_headers: list, string or regex\n\n    :param supports_credentials:\n        Allows users to make authenticated requests. If true, injects the\n        `Access-Control-Allow-Credentials` header in responses. This allows\n        cookies and credentials to be submitted across domains.\n\n        :note: This option cannot be used in conjunction with a '*' origin\n\n        Default : False\n    :type supports_credentials: bool\n\n    :param max_age:\n        The maximum time for which this CORS request maybe cached. This value\n        is set as the `Access-Control-Max-Age` header.\n\n        Default : None\n    :type max_age: timedelta, integer, string or None\n\n    :param send_wildcard: If True, and the origins parameter is `*`, a wildcard\n        `Access-Control-Allow-Origin` header is sent, rather than the\n        request's `Origin` header.\n\n        Default : False\n    :type send_wildcard: bool\n\n    :param vary_header:\n        If True, the header Vary: Origin will be returned as per the W3\n        implementation guidelines.\n\n        Setting this header when the `Access-Control-Allow-Origin` is\n        dynamically generated (e.g. when there is more than one allowed\n        origin, and an Origin than '*' is returned) informs CDNs and other\n        caches that the CORS headers are dynamic, and cannot be cached.\n\n        If False, the Vary header will never be injected or altered.\n\n        Default : True\n    :type vary_header: bool\n\n    :param automatic_options:\n        Only applies to the `cross_origin` decorator. If True, Flask-CORS will\n        override Flask's default OPTIONS handling to return CORS headers for\n        OPTIONS requests.\n\n        Default : True\n    :type automatic_options: bool\n\n    \"\"\"\n    _options = kwargs\n\n    def decorator(f):\n        LOG.debug(\"Enabling %s for cross_origin using options:%s\", f, _options)\n\n        # If True, intercept OPTIONS requests by modifying the view function,\n        # replicating Flask's default behavior, and wrapping the response with\n        # CORS headers.\n        #\n        # If f.provide_automatic_options is unset or True, Flask's route\n        # decorator (which is actually wraps the function object we return)\n        # intercepts OPTIONS handling, and requests will not have CORS headers\n        if _options.get(\"automatic_options\", True):\n            f.required_methods = getattr(f, \"required_methods\", set())\n            f.required_methods.add(\"OPTIONS\")\n            f.provide_automatic_options = False\n\n        def wrapped_function(*args, **kwargs):\n            # Handle setting of Flask-Cors parameters\n            options = get_cors_options(current_app, _options)\n\n            if options.get(\"automatic_options\") and request.method == \"OPTIONS\":\n                resp = current_app.make_default_options_response()\n            else:\n                resp = make_response(f(*args, **kwargs))\n\n            set_cors_headers(resp, options)\n            setattr(resp, FLASK_CORS_EVALUATED, True)\n            return resp\n\n        return update_wrapper(wrapped_function, f)\n\n    return decorator\n</code></pre>"},{"location":"extension/","title":"Extension","text":""},{"location":"extension/#flask_cors.extension.CORS","title":"<code>CORS</code>","text":"<p>Initializes Cross Origin Resource sharing for the application. The arguments are identical to <code>cross_origin</code>, with the addition of a <code>resources</code> parameter. The resources parameter defines a series of regular expressions for resource paths to match and optionally, the associated options to be applied to the particular resource. These options are identical to the arguments to <code>cross_origin</code>.</p> <p>The settings for CORS are determined in the following order</p> <ol> <li>Resource level settings (e.g when passed as a dictionary)</li> <li>Keyword argument settings</li> <li>App level configuration settings (e.g. CORS_*)</li> <li>Default settings</li> </ol> <p>Note: as it is possible for multiple regular expressions to match a resource path, the regular expressions are first sorted by length, from longest to shortest, in order to attempt to match the most specific regular expression. This allows the definition of a number of specific resource options, with a wildcard fallback for all other resources.</p> <p>Parameters:</p> Name Type Description Default <code>resources</code> <code>dict, iterable | string</code> <p>The series of regular expression and (optionally) associated CORS options to be applied to the given resource path.  If the argument is a dictionary, it's keys must be regular expressions, and the values must be a dictionary of kwargs, identical to the kwargs of this function.  If the argument is a list, it is expected to be a list of regular expressions, for which the app-wide configured options are applied.  If the argument is a string, it is expected to be a regular expression for which the app-wide configured options are applied.  Default : Match all and apply app-level configuration</p> required <code>origins</code> <code>list, string | regex</code> <p>The origin, or list of origins to allow requests from. The origin(s) may be regular expressions, case-sensitive strings, or else an asterisk.  ..  note::  origins must include the schema and the port (if not port 80), e.g., <code>CORS(app, origins=[\"http://localhost:8000\", \"https://example.com\"])</code>.  Default : '*'</p> required <code>methods</code> <code>list | string</code> <p>The method or list of methods which the allowed origins are allowed to access for non-simple requests.  Default : [GET, HEAD, POST, OPTIONS, PUT, PATCH, DELETE]</p> required <code>expose_headers</code> <code>list | string</code> <p>The header or list which are safe to expose to the API of a CORS API specification.  Default : None</p> required <code>allow_headers</code> <code>list, string | regex</code> <p>The header or list of header field names which can be used when this resource is accessed by allowed origins. The header(s) may be regular expressions, case-sensitive strings, or else an asterisk.  Default : '*', allow all headers</p> required <code>supports_credentials</code> <code>bool</code> <p>Allows users to make authenticated requests. If true, injects the <code>Access-Control-Allow-Credentials</code> header in responses. This allows cookies and credentials to be submitted across domains.  :note: This option cannot be used in conjunction with a '*' origin  Default : False</p> required <code>max_age</code> <code>timedelta, integer, string | None</code> <p>The maximum time for which this CORS request maybe cached. This value is set as the <code>Access-Control-Max-Age</code> header.  Default : None</p> required <code>send_wildcard</code> <code>bool</code> <p>If True, and the origins parameter is <code>*</code>, a wildcard <code>Access-Control-Allow-Origin</code> header is sent, rather than the request's <code>Origin</code> header.  Default : False</p> required <code>vary_header</code> <code>bool</code> <p>If True, the header Vary: Origin will be returned as per the W3 implementation guidelines.  Setting this header when the <code>Access-Control-Allow-Origin</code> is dynamically generated (e.g. when there is more than one allowed origin, and an Origin than '*' is returned) informs CDNs and other caches that the CORS headers are dynamic, and cannot be cached.  If False, the Vary header will never be injected or altered.  Default : True</p> required <code>allow_private_network</code> <code>bool</code> <p>If True, the response header <code>Access-Control-Allow-Private-Network</code> will be set with the value 'true' whenever the request header <code>Access-Control-Request-Private-Network</code> has a value 'true'.  If False, the response header <code>Access-Control-Allow-Private-Network</code> will be set with the value 'false' whenever the request header <code>Access-Control-Request-Private-Network</code> has a value of 'true'.  If the request header <code>Access-Control-Request-Private-Network</code> is not present or has a value other than 'true', the response header <code>Access-Control-Allow-Private-Network</code> will not be set.  Default : True</p> required Source code in <code>flask_cors/extension.py</code> <pre><code>class CORS:\n    \"\"\"\n    Initializes Cross Origin Resource sharing for the application. The\n    arguments are identical to `cross_origin`, with the addition of a\n    `resources` parameter. The resources parameter defines a series of regular\n    expressions for resource paths to match and optionally, the associated\n    options to be applied to the particular resource. These options are\n    identical to the arguments to `cross_origin`.\n\n    The settings for CORS are determined in the following order\n\n    1. Resource level settings (e.g when passed as a dictionary)\n    2. Keyword argument settings\n    3. App level configuration settings (e.g. CORS_*)\n    4. Default settings\n\n    Note: as it is possible for multiple regular expressions to match a\n    resource path, the regular expressions are first sorted by length,\n    from longest to shortest, in order to attempt to match the most\n    specific regular expression. This allows the definition of a\n    number of specific resource options, with a wildcard fallback\n    for all other resources.\n\n    :param resources:\n        The series of regular expression and (optionally) associated CORS\n        options to be applied to the given resource path.\n\n        If the argument is a dictionary, it's keys must be regular expressions,\n        and the values must be a dictionary of kwargs, identical to the kwargs\n        of this function.\n\n        If the argument is a list, it is expected to be a list of regular\n        expressions, for which the app-wide configured options are applied.\n\n        If the argument is a string, it is expected to be a regular expression\n        for which the app-wide configured options are applied.\n\n        Default : Match all and apply app-level configuration\n\n    :type resources: dict, iterable or string\n\n    :param origins:\n        The origin, or list of origins to allow requests from.\n        The origin(s) may be regular expressions, case-sensitive strings,\n        or else an asterisk.\n\n        ..  note::\n\n            origins must include the schema and the port (if not port 80),\n            e.g.,\n            `CORS(app, origins=[\"http://localhost:8000\", \"https://example.com\"])`.\n\n        Default : '*'\n    :type origins: list, string or regex\n\n    :param methods:\n        The method or list of methods which the allowed origins are allowed to\n        access for non-simple requests.\n\n        Default : [GET, HEAD, POST, OPTIONS, PUT, PATCH, DELETE]\n    :type methods: list or string\n\n    :param expose_headers:\n        The header or list which are safe to expose to the API of a CORS API\n        specification.\n\n        Default : None\n    :type expose_headers: list or string\n\n    :param allow_headers:\n        The header or list of header field names which can be used when this\n        resource is accessed by allowed origins. The header(s) may be regular\n        expressions, case-sensitive strings, or else an asterisk.\n\n        Default : '*', allow all headers\n    :type allow_headers: list, string or regex\n\n    :param supports_credentials:\n        Allows users to make authenticated requests. If true, injects the\n        `Access-Control-Allow-Credentials` header in responses. This allows\n        cookies and credentials to be submitted across domains.\n\n        :note: This option cannot be used in conjunction with a '*' origin\n\n        Default : False\n    :type supports_credentials: bool\n\n    :param max_age:\n        The maximum time for which this CORS request maybe cached. This value\n        is set as the `Access-Control-Max-Age` header.\n\n        Default : None\n    :type max_age: timedelta, integer, string or None\n\n    :param send_wildcard: If True, and the origins parameter is `*`, a wildcard\n        `Access-Control-Allow-Origin` header is sent, rather than the\n        request's `Origin` header.\n\n        Default : False\n    :type send_wildcard: bool\n\n    :param vary_header:\n        If True, the header Vary: Origin will be returned as per the W3\n        implementation guidelines.\n\n        Setting this header when the `Access-Control-Allow-Origin` is\n        dynamically generated (e.g. when there is more than one allowed\n        origin, and an Origin than '*' is returned) informs CDNs and other\n        caches that the CORS headers are dynamic, and cannot be cached.\n\n        If False, the Vary header will never be injected or altered.\n\n        Default : True\n    :type vary_header: bool\n\n    :param allow_private_network:\n        If True, the response header `Access-Control-Allow-Private-Network`\n        will be set with the value 'true' whenever the request header\n        `Access-Control-Request-Private-Network` has a value 'true'.\n\n        If False, the response header `Access-Control-Allow-Private-Network`\n        will be set with the value 'false' whenever the request header\n        `Access-Control-Request-Private-Network` has a value of 'true'.\n\n        If the request header `Access-Control-Request-Private-Network` is\n        not present or has a value other than 'true', the response header\n        `Access-Control-Allow-Private-Network` will not be set.\n\n        Default : True\n    :type allow_private_network: bool\n    \"\"\"\n\n    def __init__(self, app=None, **kwargs):\n        self._options = kwargs\n        if app is not None:\n            self.init_app(app, **kwargs)\n\n    def init_app(self, app, **kwargs):\n        # The resources and options may be specified in the App Config, the CORS constructor\n        # or the kwargs to the call to init_app.\n        options = get_cors_options(app, self._options, kwargs)\n\n        # Flatten our resources into a list of the form\n        # (pattern_or_regexp, dictionary_of_options)\n        resources = parse_resources(options.get(\"resources\"))\n\n        # Compute the options for each resource by combining the options from\n        # the app's configuration, the constructor, the kwargs to init_app, and\n        # finally the options specified in the resources dictionary.\n        resources = [(pattern, get_cors_options(app, options, opts)) for (pattern, opts) in resources]\n\n        # Create a human-readable form of these resources by converting the compiled\n        # regular expressions into strings.\n        resources_human = {get_regexp_pattern(pattern): opts for (pattern, opts) in resources}\n        LOG.debug(\"Configuring CORS with resources: %s\", resources_human)\n\n        cors_after_request = make_after_request_function(resources)\n        app.after_request(cors_after_request)\n\n        # Wrap exception handlers with cross_origin\n        # These error handlers will still respect the behavior of the route\n        if options.get(\"intercept_exceptions\", True):\n\n            def _after_request_decorator(f):\n                def wrapped_function(*args, **kwargs):\n                    return cors_after_request(app.make_response(f(*args, **kwargs)))\n\n                return wrapped_function\n\n            if hasattr(app, \"handle_exception\"):\n                app.handle_exception = _after_request_decorator(app.handle_exception)\n                app.handle_user_exception = _after_request_decorator(app.handle_user_exception)\n</code></pre>"},{"location":"examples/blueprints/","title":"Using CORS with Blueprints","text":"<p>Flask-CORS supports blueprints out of the box. Simply pass a <code>blueprint</code> instance to the CORS extension, and everything will just work.</p> <pre><code>\"\"\"\nFlask-Cors example\n===================\nThis is a tiny Flask Application demonstrating Flask-Cors, making it simple\nto add cross origin support to your flask app!\n\n:copyright: (c) 2016 by Cory Dolphin.\n:license:   MIT/X11, see LICENSE for more details.\n\"\"\"\nfrom flask import Flask, jsonify, Blueprint\nimport logging\ntry:\n    from flask_cors import CORS  # The typical way to import flask-cors\nexcept ImportError:\n    # Path hack allows examples to be run without installation.\n    import os\n    parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    os.sys.path.insert(0, parentdir)\n\n    from flask_cors import CORS\n\n\napi_v1 = Blueprint('API_v1', __name__)\n\nCORS(api_v1) # enable CORS on the API_v1 blue print\n\n@api_v1.route(\"/api/v1/users/\")\ndef list_users():\n    '''\n        Since the path matches the regular expression r'/api/*', this resource\n        automatically has CORS headers set. The expected result is as follows:\n\n        $ curl --include -X GET http://127.0.0.1:5000/api/v1/users/ \\\n            --header Origin:www.examplesite.com\n        HTTP/1.0 200 OK\n        Access-Control-Allow-Headers: Content-Type\n        Access-Control-Allow-Origin: *\n        Content-Length: 21\n        Content-Type: application/json\n        Date: Sat, 09 Aug 2014 00:26:41 GMT\n        Server: Werkzeug/0.9.4 Python/2.7.8\n\n        {\n            \"success\": true\n        }\n\n    '''\n    return jsonify(user=\"joe\")\n\n\n@api_v1.route(\"/api/v1/users/create\", methods=['POST'])\ndef create_user():\n    '''\n        Since the path matches the regular expression r'/api/*', this resource\n        automatically has CORS headers set.\n\n        Browsers will first make a preflight request to verify that the resource\n        allows cross-origin POSTs with a JSON Content-Type, which can be simulated\n        as:\n        $ curl --include -X OPTIONS http://127.0.0.1:5000/api/v1/users/create \\\n            --header Access-Control-Request-Method:POST \\\n            --header Access-Control-Request-Headers:Content-Type \\\n            --header Origin:www.examplesite.com\n        &gt;&gt; HTTP/1.0 200 OK\n        Content-Type: text/html; charset=utf-8\n        Allow: POST, OPTIONS\n        Access-Control-Allow-Origin: *\n        Access-Control-Allow-Headers: Content-Type\n        Access-Control-Allow-Methods: DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT\n        Content-Length: 0\n        Server: Werkzeug/0.9.6 Python/2.7.9\n        Date: Sat, 31 Jan 2015 22:25:22 GMT\n\n\n        $ curl --include -X POST http://127.0.0.1:5000/api/v1/users/create \\\n            --header Content-Type:application/json \\\n            --header Origin:www.examplesite.com\n\n\n        &gt;&gt; HTTP/1.0 200 OK\n        Content-Type: application/json\n        Content-Length: 21\n        Access-Control-Allow-Origin: *\n        Server: Werkzeug/0.9.6 Python/2.7.9\n        Date: Sat, 31 Jan 2015 22:25:04 GMT\n\n        {\n          \"success\": true\n        }\n\n    '''\n    return jsonify(success=True)\n\npublic_routes = Blueprint('public', __name__)\n\n@public_routes.route(\"/\")\ndef helloWorld():\n    '''\n        Since the path '/' does not match the regular expression r'/api/*',\n        this route does not have CORS headers set.\n    '''\n    return '''&lt;h1&gt;Hello CORS!&lt;/h1&gt; Read about my spec at the\n&lt;a href=\"http://www.w3.org/TR/cors/\"&gt;W3&lt;/a&gt; Or, checkout my documentation\non &lt;a href=\"https://github.com/corydolphin/flask-cors\"&gt;Github&lt;/a&gt;'''\n\n\nlogging.basicConfig(level=logging.INFO)\napp = Flask('FlaskCorsBlueprintBasedExample')\napp.register_blueprint(api_v1)\napp.register_blueprint(public_routes)\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n</code></pre>"},{"location":"examples/decorator/","title":"Using CORS with a view decorator","text":"<p>Flask-CORS can be used as a decorator on views, which makes it easy to isolate it to a small subset of views.</p> <pre><code>\"\"\"\nFlask-Cors example\n===================\nThis is a tiny Flask Application demonstrating Flask-Cors, making it simple\nto add cross origin support to your flask app!\n\n:copyright: (c) 2016 by Cory Dolphin.\n:license:   MIT/X11, see LICENSE for more details.\n\"\"\"\nfrom flask import Flask, jsonify\nimport logging\ntry:\n    # The typical way to import flask-cors\n    from flask_cors import cross_origin\nexcept ImportError:\n    # Path hack allows examples to be run without installation.\n    import os\n    parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    os.sys.path.insert(0, parentdir)\n\n    from flask_cors import cross_origin\n\n\napp = Flask('FlaskCorsViewBasedExample')\nlogging.basicConfig(level=logging.INFO)\n\n@app.route(\"/\", methods=['GET'])\n@cross_origin()\ndef helloWorld():\n    '''\n        This view has CORS enabled for all domains, representing the simplest\n        configuration of view-based decoration. The expected result is as\n        follows:\n\n        $ curl --include -X GET http://127.0.0.1:5000/ \\\n            --header Origin:www.examplesite.com\n\n        &gt;&gt; HTTP/1.0 200 OK\n        Content-Type: text/html; charset=utf-8\n        Content-Length: 184\n        Access-Control-Allow-Origin: *\n        Server: Werkzeug/0.9.6 Python/2.7.9\n        Date: Sat, 31 Jan 2015 22:29:56 GMT\n\n        &lt;h1&gt;Hello CORS!&lt;/h1&gt; Read about my spec at the\n        &lt;a href=\"http://www.w3.org/TR/cors/\"&gt;W3&lt;/a&gt; Or, checkout my documentation\n        on &lt;a href=\"https://github.com/corydolphin/flask-cors\"&gt;Github&lt;/a&gt;\n\n    '''\n    return '''&lt;h1&gt;Hello CORS!&lt;/h1&gt; Read about my spec at the\n&lt;a href=\"http://www.w3.org/TR/cors/\"&gt;W3&lt;/a&gt; Or, checkout my documentation\non &lt;a href=\"https://github.com/corydolphin/flask-cors\"&gt;Github&lt;/a&gt;'''\n\n\n@app.route(\"/api/v1/users/create\", methods=['GET', 'POST'])\n@cross_origin(allow_headers=['Content-Type'])\ndef cross_origin_json_post():\n    '''\n        This view has CORS enabled for all domains, and allows browsers\n        to send the Content-Type header, allowing cross domain AJAX POST\n        requests.\n\n Browsers will first make a preflight request to verify that the resource\n        allows cross-origin POSTs with a JSON Content-Type, which can be simulated\n        as:\n        $ curl --include -X OPTIONS http://127.0.0.1:5000/api/v1/users/create \\\n            --header Access-Control-Request-Method:POST \\\n            --header Access-Control-Request-Headers:Content-Type \\\n            --header Origin:www.examplesite.com\n        &gt;&gt; HTTP/1.0 200 OK\n        Content-Type: text/html; charset=utf-8\n        Allow: POST, OPTIONS\n        Access-Control-Allow-Origin: *\n        Access-Control-Allow-Headers: Content-Type\n        Access-Control-Allow-Methods: DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT\n        Content-Length: 0\n        Server: Werkzeug/0.9.6 Python/2.7.9\n        Date: Sat, 31 Jan 2015 22:25:22 GMT\n\n\n        $ curl --include -X POST http://127.0.0.1:5000/api/v1/users/create \\\n            --header Content-Type:application/json \\\n            --header Origin:www.examplesite.com\n\n\n        &gt;&gt; HTTP/1.0 200 OK\n        Content-Type: application/json\n        Content-Length: 21\n        Access-Control-Allow-Origin: *\n        Server: Werkzeug/0.9.6 Python/2.7.9\n        Date: Sat, 31 Jan 2015 22:25:04 GMT\n\n        {\n          \"success\": true\n        }\n\n    '''\n\n    return jsonify(success=True)\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n</code></pre>"},{"location":"examples/extension/","title":"Using the extension","text":"<p>Flask-CORS can be used as an extension to provide centralized configuration of resources by patterns,</p> <pre><code>\"\"\"\nFlask-Cors example\n===================\nThis is a tiny Flask Application demonstrating Flask-Cors, making it simple\nto add cross origin support to your flask app!\n\n:copyright: (c) 2016 by Cory Dolphin.\n:license:   MIT/X11, see LICENSE for more details.\n\"\"\"\nfrom flask import Flask, jsonify\nimport logging\ntry:\n    from flask_cors import CORS  # The typical way to import flask-cors\nexcept ImportError:\n    # Path hack allows examples to be run without installation.\n    import os\n    parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    os.sys.path.insert(0, parentdir)\n\n    from flask_cors import CORS\n\n\napp = Flask('FlaskCorsAppBasedExample')\nlogging.basicConfig(level=logging.INFO)\n\n# To enable logging for flask-cors,\nlogging.getLogger('flask_cors').level = logging.DEBUG\n\n# One of the simplest configurations. Exposes all resources matching /api/* to\n# CORS and allows the Content-Type header, which is necessary to POST JSON\n# cross origin.\nCORS(app, resources=r'/api/*')\n\n\n@app.route(\"/\")\ndef helloWorld():\n    \"\"\"\n        Since the path '/' does not match the regular expression r'/api/*',\n        this route does not have CORS headers set.\n    \"\"\"\n    return '''\n&lt;html&gt;\n    &lt;h1&gt;Hello CORS!&lt;/h1&gt;\n    &lt;h3&gt; End to end editable example with jquery! &lt;/h3&gt;\n    &lt;a class=\"jsbin-embed\" href=\"http://jsbin.com/zazitas/embed?js,console\"&gt;JS Bin on jsbin.com&lt;/a&gt;\n    &lt;script src=\"//static.jsbin.com/js/embed.min.js?3.35.12\"&gt;&lt;/script&gt;\n\n&lt;/html&gt;\n'''\n\n@app.route(\"/api/v1/users/\")\ndef list_users():\n    \"\"\"\n        Since the path matches the regular expression r'/api/*', this resource\n        automatically has CORS headers set. The expected result is as follows:\n\n        $ curl --include -X GET http://127.0.0.1:5000/api/v1/users/ \\\n            --header Origin:www.examplesite.com\n        HTTP/1.0 200 OK\n        Access-Control-Allow-Headers: Content-Type\n        Access-Control-Allow-Origin: *\n        Content-Length: 21\n        Content-Type: application/json\n        Date: Sat, 09 Aug 2014 00:26:41 GMT\n        Server: Werkzeug/0.9.4 Python/2.7.8\n\n        {\n            \"success\": true\n        }\n\n    \"\"\"\n    return jsonify(user=\"joe\")\n\n\n@app.route(\"/api/v1/users/create\", methods=['POST'])\ndef create_user():\n    \"\"\"\n        Since the path matches the regular expression r'/api/*', this resource\n        automatically has CORS headers set.\n\n        Browsers will first make a preflight request to verify that the resource\n        allows cross-origin POSTs with a JSON Content-Type, which can be simulated\n        as:\n        $ curl --include -X OPTIONS http://127.0.0.1:5000/api/v1/users/create \\\n            --header Access-Control-Request-Method:POST \\\n            --header Access-Control-Request-Headers:Content-Type \\\n            --header Origin:www.examplesite.com\n        &gt;&gt; HTTP/1.0 200 OK\n        Content-Type: text/html; charset=utf-8\n        Allow: POST, OPTIONS\n        Access-Control-Allow-Origin: *\n        Access-Control-Allow-Headers: Content-Type\n        Access-Control-Allow-Methods: DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT\n        Content-Length: 0\n        Server: Werkzeug/0.9.6 Python/2.7.9\n        Date: Sat, 31 Jan 2015 22:25:22 GMT\n\n\n        $ curl --include -X POST http://127.0.0.1:5000/api/v1/users/create \\\n            --header Content-Type:application/json \\\n            --header Origin:www.examplesite.com\n\n\n        &gt;&gt; HTTP/1.0 200 OK\n        Content-Type: application/json\n        Content-Length: 21\n        Access-Control-Allow-Origin: *\n        Server: Werkzeug/0.9.6 Python/2.7.9\n        Date: Sat, 31 Jan 2015 22:25:04 GMT\n\n        {\n          \"success\": true\n        }\n\n    \"\"\"\n    return jsonify(success=True)\n\n@app.route(\"/api/exception\")\ndef get_exception():\n    \"\"\"\n        Since the path matches the regular expression r'/api/*', this resource\n        automatically has CORS headers set.\n\n        Browsers will first make a preflight request to verify that the resource\n        allows cross-origin POSTs with a JSON Content-Type, which can be simulated\n        as:\n        $ curl --include -X OPTIONS http://127.0.0.1:5000/api/exception \\\n            --header Access-Control-Request-Method:POST \\\n            --header Access-Control-Request-Headers:Content-Type \\\n            --header Origin:www.examplesite.com\n        &gt;&gt; HTTP/1.0 200 OK\n        Content-Type: text/html; charset=utf-8\n        Allow: POST, OPTIONS\n        Access-Control-Allow-Origin: *\n        Access-Control-Allow-Headers: Content-Type\n        Access-Control-Allow-Methods: DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT\n        Content-Length: 0\n        Server: Werkzeug/0.9.6 Python/2.7.9\n        Date: Sat, 31 Jan 2015 22:25:22 GMT\n    \"\"\"\n    raise Exception(\"example\")\n\n@app.errorhandler(500)\ndef server_error(e):\n    logging.exception('An error occurred during a request. %s', e)\n    return \"An internal error occurred\", 500\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n</code></pre>"}]}